using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace TaggedEnum;

[Generator(LanguageNames.CSharp)]
public sealed class TaggedEnumSourceGenerator: IIncrementalGenerator {
	public void Initialize(IncrementalGeneratorInitializationContext context) {
		static bool IsEnum(SyntaxNode node, CancellationToken cancellationToken) => node is EnumDeclarationSyntax;
		
		Span<string> taggedAttrs = ["TaggedEnum.Tagged", "TaggedEnum.Tagged`1"];
		foreach (var taggedAttrName in taggedAttrs) {
			var provider = context.SyntaxProvider.ForAttributeWithMetadataName(taggedAttrName, 
				IsEnum,
				TransformEnumPayload
			)
			.Where(NotNull)
			.Select(static (v, _) => ToNonNullable(v))
			.Select(ProcessMembers);

			context.RegisterSourceOutput(provider, GenerateSource);
		}
	}

	private static TypeInfo? TransformEnumPayload(GeneratorAttributeSyntaxContext ctx, CancellationToken cancellationToken) {
		// if (!Debugger.IsAttached){
		// 	Debugger.Launch();
		// }

		if (ctx is not {
			TargetNode: EnumDeclarationSyntax {
				Modifiers: var modifiers
			} targetNode,
			TargetSymbol: INamedTypeSymbol targetSymbol,
			SemanticModel.Compilation: var compilation,
			Attributes: [{
				AttributeClass: {} attr
			} attrConstructor, ..]
		}) {
			return null;
		}
		
		var attrSymbolList = targetSymbol.GetAttributes();
		var taggedType = compilation.GetTypeByMetadataName("TaggedEnum.Tagged");
		var taggedGenericType = compilation.GetTypeByMetadataName("TaggedEnum.Tagged`1");
		var taggedAttrList = attrSymbolList
			.Select(static data => data?.AttributeClass)
			.Where(NotNull)
			.Where(data => SymbolEqualityComparer.Default.Equals(data, taggedType) || (!data!.IsDefinition && SymbolEqualityComparer.Default.Equals(data.OriginalDefinition, taggedGenericType)));
		
		if (taggedAttrList.Count() > 1) {
			// TODO　发出错误警告
			return null;
		}
		

		var data = new TypeInfo() {
				Node = targetNode,
				SemanticModel = ctx.SemanticModel,
				Symbol = targetSymbol,
				TypeName = targetSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
				NamespaceName = targetSymbol.ContainingNamespace.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
				Modifiers = modifiers.ToString()
		};
		if (attr.IsGenericType) {
			var genericArg = attr.TypeArguments[0];
			if (genericArg.SpecialType != SpecialType.System_String
				&& genericArg.SpecialType != SpecialType.System_Char
				&& genericArg.SpecialType != SpecialType.System_Int16
				&& genericArg.SpecialType != SpecialType.System_Int32
				&& genericArg.SpecialType != SpecialType.System_Int64
				&& genericArg.SpecialType != SpecialType.System_UInt16
				&& genericArg.SpecialType != SpecialType.System_UInt32
				&& genericArg.SpecialType != SpecialType.System_UInt64
				&& genericArg.SpecialType != SpecialType.System_Boolean
				&& genericArg.SpecialType != SpecialType.System_Byte
				&& genericArg.SpecialType != SpecialType.System_SByte
				&& genericArg.SpecialType != SpecialType.System_Single
				&& genericArg.SpecialType != SpecialType.System_Double
				) {
				// TODO　发出错误警告
				return null;
			}
			data.ValueTypeName = genericArg.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
		} else if (attrConstructor is {
			NamedArguments: [{
				Key: "UseAll",
				Value.Value: true
			}]
		}) {
			data.UseAll = true;
		}
		return data;
	}
	
	private void GenerateSource(SourceProductionContext ctx, FinalResult data) {
		// if (!Debugger.IsAttached) {
		// 	Debugger.Launch();
		// }
		var globalLength = "global::".Length;
		var @namespace = data.Type.NamespaceName == "<global namespace>" ? "" : $"namespace {data.Type.NamespaceName[globalLength..]};";
		var typeName = data.Type.TypeName[globalLength..];
		var nameValueMap = data.Members.Select(m => $@"{{{data.Type.TypeName}.{m.MemberName}, ""{data.Type.TypeName}.{m.MemberName}""}},").Aggregate("", static (current, next) => current + "\n\t\t" + next);
		var conditionalBranches = data.Members.Where(static m => m.HasValue).Select(m => $"{data.Type.TypeName}.{m.MemberName} => ({m.TypeName}){m.Value},").Aggregate("", static (current, next) => current + "\n\t\t\t" + next);
		var source = $$"""
		// <auto-generated />
		#nullable enable
		using System.Runtime.CompilerServices;
		using TaggedEnum;

		{{@namespace}}

		[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]
		[global::System.CodeDom.Compiler.GeneratedCodeAttribute("TaggedEnum", "1.0")]
		{{data.Type.Modifiers}} static class {{typeName}}Extension {
			private static readonly Dictionary<{{data.Type.TypeName}}, string> NameValueMap = new() {
				{{nameValueMap}}
			};

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]
			[global::System.CodeDom.Compiler.GeneratedCodeAttribute("TaggedEnum", "1.0")]
			public static {{data.Type.ValueTypeName}} Value(this {{data.Type.TypeName}} self) 
				=> self switch {
					{{conditionalBranches}}
					_ => throw new ValueNotFoundException($"Value of {NameValueMap[self]} not found.")
				};
		}
		""";
		ctx.AddSource($"{(data.Type.NamespaceName == "<global namespace>" ? "" : data.Type.NamespaceName["global::".Length..])}{data.Type.TypeName["global::".Length..]}TaggedEnum.g.cs", SourceText.From(source, Encoding.UTF8));
	}

	private static FinalResult ProcessMembers(TypeInfo enumTypeInfo, CancellationToken cancellationToken) {
		// if (!Debugger.IsAttached) {
		// 	Debugger.Launch();
		// }
		var valueType = enumTypeInfo.SemanticModel.Compilation.GetTypeByMetadataName("TaggedEnum.Value");
		var valueGenericType = enumTypeInfo.SemanticModel.Compilation.GetTypeByMetadataName("TaggedEnum.Value`1");
		var memberValueMap = enumTypeInfo.Symbol.GetMembers()
			.OfType<IFieldSymbol>()
			.Select((m, cancellationToken) => {
				var memberValueAttrData = m.GetAttributes()
					.Where(attrData => 
						NotNull(attrData)
						&& NotNull(attrData.AttributeClass)
						&& (SymbolEqualityComparer.Default.Equals(attrData.AttributeClass, valueType)
						|| (!attrData.AttributeClass.IsDefinition
							&& SymbolEqualityComparer.Default.Equals(attrData.AttributeClass.OriginalDefinition, valueGenericType))));

				var valueAttrCount = memberValueAttrData.Count();
				var memberInfo = new MemberInfo() {
					MemberName = m.Name,
					FieldValue = m.ConstantValue!.ToString()
				};

				if (valueAttrCount > 1) {
					// TODO error
				} else if (valueAttrCount == 0) {
					if (enumTypeInfo.UseAll) {
						memberInfo.Value = $@"""{m.Name}""";
						memberInfo.TypeName = "string";
						memberInfo.HasValue = true;
					} else {
						// TODO error
					}
				} else {
					var valueAttrData = memberValueAttrData.FirstOrDefault();

					if (valueAttrData.ConstructorArguments.Length > 0) {
						var value = valueAttrData.ConstructorArguments.FirstOrDefault();
						var valueTypeName = value.Type?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
						if (valueTypeName != enumTypeInfo.ValueTypeName) {
							// TODO error
						} else {
							memberInfo.Value = value.Value is string str ? $@"""{str}""" : value.Value?.ToString() ?? string.Empty;
							memberInfo.TypeName = valueTypeName; 
							memberInfo.HasValue = true;
						}
					} else if (enumTypeInfo.ValueTypeName != TypeInfo.DefaultType) {
						// TODO error
					} else {
						memberInfo.Value = $@"""{m.Name}""";
						memberInfo.TypeName = "string";
						memberInfo.HasValue = true;
					}
				}
				return memberInfo;
			});
		
		return new FinalResult() {
			Type = enumTypeInfo,
			Members = memberValueMap
		};
	}
	
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool NotNullClass<T>([NotNullWhen(true)]T? v) where T: class => v is not null;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool NotNull<T>([NotNullWhen(true)]T? v) => v is not null;

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static T ToNonNullable<T>(T? v) where T: struct => v!.Value;
}

internal struct TypeInfo {
	public const string DefaultType = "string";
	public TypeInfo() {}
	public bool UseAll = false;
	public required SemanticModel SemanticModel { get; init; }
	public required EnumDeclarationSyntax Node { get; init; }
	public required INamedTypeSymbol Symbol { get; init; }
	public required string TypeName { get; init; }
	public required string NamespaceName { get; init; }
	// public ITypeSymbol ValueType { get; init; };
	public string ValueTypeName = DefaultType;
	public required string Modifiers { get; init; }
}

internal struct MemberInfo {
	public MemberInfo() {}
	
	public bool HasValue = false;
	
	public required string MemberName { get; init; }
	
	public string Value = string.Empty;

	public string TypeName = string.Empty;

	public required string FieldValue;
}

internal readonly struct FinalResult {
	public FinalResult() {}
	
	public required TypeInfo Type { get; init; }
	public required IEnumerable<MemberInfo> Members { get; init; }
}